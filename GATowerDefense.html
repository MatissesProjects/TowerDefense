<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Tower Defense</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #1a4d2e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --path-color: #6b5a4d;
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Roboto', sans-serif;
            --border-radius: 8px;
            --tower-placement-allowed: rgba(46, 204, 113, 0.5);
            --tower-placement-denied: rgba(231, 76, 60, 0.5);
        }
        body {
            background-color: var(--bg-color); color: var(--text-color); font-family: var(--font-body);
            display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box;
        }
        .game-container { position: relative; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; max-width: 1200px; }
        .main-content { display: flex; flex-direction: row; gap: 20px; width: 100%; }
        canvas { background-color: var(--primary-color); border-radius: var(--border-radius); box-shadow: 0 0 25px rgba(0, 0, 0, 0.5); cursor: pointer; flex-grow: 1; max-width: 800px; aspect-ratio: 4 / 3; width: 100%; height: auto; }
        .ui-panel { background-color: var(--primary-color); border-radius: var(--border-radius); padding: 20px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; gap: 15px; }
        .stats-panel { width: 250px; flex-shrink: 0; }
        .stats-panel h2, .controls-panel h2, .tower-controls-panel h3 { font-family: var(--font-display); text-align: center; margin: 0; color: var(--accent-color); border-bottom: 2px solid var(--secondary-color); padding-bottom: 10px; }
        .stat-item { display: flex; justify-content: space-between; font-size: 1.1em; padding: 10px; background-color: var(--secondary-color); border-radius: 5px; }
        .stat-item span:first-child { font-weight: bold; }
        .controls-panel { width: 100%; }
        .tower-selection { display: flex; gap: 15px; justify-content: center; margin-bottom: 15px; }
        .tower-option { background-color: var(--secondary-color); border: 2px solid transparent; padding: 10px; border-radius: var(--border-radius); cursor: pointer; transition: all 0.3s ease; text-align: center; width: 120px; }
        .tower-option:hover { border-color: var(--accent-color); transform: translateY(-3px); }
        .tower-option.selected { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color); }
        .tower-icon { font-size: 2em; }
        .tower-cost { font-weight: bold; color: var(--accent-color); }
        .game-controls { display: flex; justify-content: center; align-items: center; gap: 15px; }
        .game-button { font-family: var(--font-display); background-color: var(--accent-color); color: var(--text-color); border: none; padding: 12px 25px; border-radius: var(--border-radius); cursor: pointer; font-size: 1em; transition: all 0.3s ease; }
        .game-button:hover:not(:disabled) { background-color: #ff6b81; }
        .game-button:disabled { background-color: #555; cursor: not-allowed; }
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
        .modal-content { background: var(--primary-color); padding: 30px; border-radius: var(--border-radius); text-align: center; box-shadow: 0 5px 30px rgba(0,0,0,0.5); border: 2px solid var(--accent-color); }
        .modal-content h2 { font-family: var(--font-display); color: var(--accent-color); font-size: 2.5em; margin-top: 0; }
        
        #children-container { display: none; flex-wrap: wrap; gap: 15px; justify-content: center; width: 100%; }
        .child-instance {
            border: 2px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 10px;
            background-color: var(--primary-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }
        .child-instance canvas { max-width: 240px; aspect-ratio: 4 / 3; }
        .child-stats {
            display: flex;
            flex-direction: column;
            font-size: 0.8em;
            width: 100%;
            gap: 3px;
        }
        .child-stat-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 6px;
            background-color: var(--secondary-color);
            border-radius: 3px;
        }

        @media (max-width: 900px) { .main-content { flex-direction: column; } .stats-panel { width: 100%; order: -1; } #gameCanvas { max-width: 100%; } }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="children-container"></div>
        <div class="main-content">
            <canvas id="gameCanvas"></canvas>
            <div class="ui-panel stats-panel">
                <h2>Game Stats</h2>
                <div class="stat-item"><span>‚ù§Ô∏è Health:</span> <span id="health">100</span></div>
                <div class="stat-item"><span>üí∞ Money:</span> <span id="money">200</span></div>
                <div class="stat-item"><span>üåä Wave:</span> <span id="wave">0</span></div>
                <div class="stat-item"><span>üëª Enemies:</span> <span id="enemies-left">0</span></div>
            </div>
        </div>
        <div class="ui-panel controls-panel">
            <h2>Build Towers</h2>
            <div class="tower-selection" id="tower-selection-ui">
                <!-- Tower options will be dynamically inserted here -->
            </div>
            <div class="game-controls">
                <button class="game-button" id="start-wave-btn">Start Next Wave</button>
                <button class="game-button" id="start-ga-btn">Start GA</button>
                <button class="game-button" id="stop-ai-btn">Stop AI</button>
                <input type="range" id="num-children-slider" min="2" max="50" value="10">
                <span id="num-children-label">Children: 10</span>
            </div>
        </div>
    </div>
    
    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-text">You have been defeated!</p>
            <button class="game-button" id="restart-game-btn">Play Again</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const getEl = id => document.getElementById(id);
        const mainCanvas = getEl('gameCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const healthEl = getEl('health'), moneyEl = getEl('money'), waveEl = getEl('wave'), enemiesLeftEl = getEl('enemies-left');
        const startWaveBtn = getEl('start-wave-btn'), restartGameBtn = getEl('restart-game-btn');
        const startGaBtn = getEl('start-ga-btn'), stopAiBtn = getEl('stop-ai-btn');
        const messageModal = getEl('message-modal'), towerSelectionUI = getEl('tower-selection-ui');
        const numChildrenSlider = getEl('num-children-slider'), numChildrenLabel = getEl('num-children-label'), childrenContainer = getEl('children-container');

        // --- Color Management ---
        const computedStyles = getComputedStyle(document.documentElement);
        let pathColor, primaryColor;
        const updateColors = () => {
            pathColor = computedStyles.getPropertyValue('--path-color');
            primaryColor = computedStyles.getPropertyValue('--primary-color');
        };

        // --- Game Data ---
        const TILE_SIZE = 40;
        const maps = [{
            name: "The Long Road",
            layout: [
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 2],
            ]
        }];
        const TOWER_SPECS = {
            turret: { name: 'Turret', icon: 'üî´', cost: 100, color: '#3498db', upgrades: { damage: { levels: [1.5, 3, 5, 8, 12], costs: [50, 90, 150, 250] }, range: { levels: [120, 135, 150, 165, 180], costs: [40, 70, 110, 180] }, fireRate: { levels: [30, 26, 22, 18, 14], costs: [60, 100, 160, 240] } } },
            frost: { name: 'Frost Tower', icon: '‚ùÑÔ∏è', cost: 80, color: '#34d3d3', upgrades: { damage: { levels: [0.5, 1, 1.5, 2, 3], costs: [40, 60, 90, 150] }, range: { levels: [100, 115, 130, 145, 160], costs: [30, 50, 80, 130] }, fireRate: { levels: [45, 40, 35, 30, 25], costs: [50, 75, 110, 170] }, slow: { levels: [0.3, 0.35, 0.4, 0.45, 0.5], costs: [70, 90, 120, 160], duration: 120 } } }
        };

        // --- Global Game State ---
        let mapLayout, originalMapLayout, path;
        let mainGame; // The primary game instance for manual play
        let aiManager;
        let mouse = { x: 0, y: 0 };
        let selectedTowerType;

        // --- Classes ---
        class GameInstance {
            constructor(canvas, uiElements = null, genome = null) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.ui = uiElements;
                this.genome = genome;
                this.fitness = 0;
                this.resetState();
                this.resizeCanvas();
            }

            resetState() {
                this.health = 100;
                this.money = 200;
                this.wave = 0;
                this.enemies = [];
                this.towers = [];
                this.projectiles = [];
                this.currentWaveActive = false;
                this.mapLayout = JSON.parse(JSON.stringify(originalMapLayout));
                this.gameState = 'idle';

                if (this.genome) {
                    this.towers = this.genome.map(g => new Tower(g.tileX * TILE_SIZE + TILE_SIZE / 2, g.tileY * TILE_SIZE + TILE_SIZE / 2, g.tileX, g.tileY, g.type, this));
                    this.towers.forEach(t => this.mapLayout[t.tileY][t.tileX] = 3);
                }
            }

            resizeCanvas() {
                this.canvas.width = mapLayout[0].length * TILE_SIZE;
                this.canvas.height = mapLayout.length * TILE_SIZE;
            }

            update() {
                if (this.gameState === 'gameOver') return;

                this.towers.forEach(tower => tower.update());
                this.projectiles = this.projectiles.filter(p => p.x > -100);
                this.projectiles.forEach(p => p.update());
                this.enemies.forEach(enemy => enemy.update());
                this.enemies = this.enemies.filter(enemy => enemy.health > 0);

                this.checkGameStatus();
                if (this.ui) {
                    this.updateUI();
                }
            }
            
            updateUI() {
                this.ui.health.textContent = this.health;
                this.ui.money.textContent = this.money;
                this.ui.wave.textContent = this.wave;
                this.ui.fitness.textContent = this.fitness.toFixed(2);
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMap();
                this.towers.forEach(tower => tower.draw(this.ctx));
                this.projectiles.forEach(p => p.draw(this.ctx));
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                 if (this.gameState === 'gameOver') {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = `bold ${this.canvas.width/10}px "Orbitron"`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Finished', this.canvas.width / 2, this.canvas.height / 2);
                }
            }
            
            drawMap() {
                for (let r = 0; r < this.mapLayout.length; r++) {
                    for (let c = 0; c < this.mapLayout[0].length; c++) {
                        this.ctx.fillStyle = this.mapLayout[r][c] >= 1 && this.mapLayout[r][c] !== 3 ? pathColor : primaryColor;
                        this.ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            startNextWave() {
                if (this.currentWaveActive || this.gameState === 'gameOver') return;
                this.wave++;
                this.currentWaveActive = true;
                const enemyCount = 5 + this.wave * 3;
                const enemyHealth = 2 + (this.wave - 1) * 2;
                const enemyReward = 5 + this.wave;
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (this.gameState !== 'gameOver') {
                            const enemy = new Enemy(this);
                            enemy.maxHealth = enemyHealth;
                            enemy.health = enemyHealth;
                            enemy.reward = enemyReward;
                            enemy.originalSpeed = 1.5 + this.wave * 0.05;
                            this.enemies.push(enemy);
                        }
                    }, i * 500);
                }
            }

            checkGameStatus() {
                if (this.health <= 0) {
                    this.gameState = 'gameOver';
                }
                if (this.currentWaveActive && this.enemies.length === 0) {
                    this.currentWaveActive = false;
                    this.money += 100 + this.wave * 10;
                }
            }
        }

        class Enemy {
            constructor(game) {
                this.game = game;
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.width = TILE_SIZE * 0.5;
                this.height = TILE_SIZE * 0.5;
                this.speed = 1.5;
                this.originalSpeed = 1.5;
                this.maxHealth = 2;
                this.health = 2;
                this.reward = 5;
                this.slowUntil = 0;
            }
            update() {
                if (Date.now() > this.slowUntil) { this.speed = this.originalSpeed; }
                if (this.pathIndex < path.length - 1) {
                    const target = path[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    if (distance < this.speed) {
                        this.pathIndex++;
                        this.x = target.x;
                        this.y = target.y;
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                } else {
                    this.game.health -= 10;
                    if (this.game.health < 0) this.game.health = 0;
                    this.health = 0;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.speed < this.originalSpeed ? '#5dade2' : '#c0392b';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                const healthBarWidth = this.width;
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.height / 2 - 10, healthBarWidth, 5);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(this.x - healthBarWidth / 2, this.y - this.height / 2 - 10, healthBarWidth * (this.health / this.maxHealth), 5);
            }
            takeDamage(damage, slowEffect) {
                this.health -= damage;
                if (slowEffect) {
                    this.speed = this.originalSpeed * (1 - slowEffect.amount);
                    this.slowUntil = Date.now() + slowEffect.duration;
                }
                if (this.health <= 0) {
                    this.game.money += this.reward;
                }
            }
        }

        class Tower {
            constructor(x, y, tileX, tileY, type, game) {
                this.x = x; this.y = y; this.tileX = tileX; this.tileY = tileY;
                this.type = type;
                this.game = game;
                this.specs = TOWER_SPECS[type];
                this.levels = { damage: 0, range: 0, fireRate: 0, slow: 0 };
                this.width = TILE_SIZE * 0.8;
                this.fireCooldown = 0;
                this.target = null;
                this.priority = 'first';
                this.updateStats();
            }
            updateStats() {
                this.damage = this.specs.upgrades.damage.levels[this.levels.damage];
                this.range = this.specs.upgrades.range.levels[this.levels.range];
                this.fireRate = this.specs.upgrades.fireRate.levels[this.levels.fireRate];
                if (this.specs.upgrades.slow) {
                    this.slowAmount = this.specs.upgrades.slow.levels[this.levels.slow];
                    this.slowDuration = this.specs.upgrades.slow.duration;
                }
            }
            findTarget() {
                const inRangeEnemies = this.game.enemies.filter(enemy => Math.hypot(this.x - enemy.x, this.y - enemy.y) < this.range);
                if (inRangeEnemies.length === 0) { this.target = null; return; }
                if (this.target && this.target.health > 0 && inRangeEnemies.includes(this.target)) { return; }
                this.target = inRangeEnemies.reduce((a, b) => (a.pathIndex > b.pathIndex ? a : b));
            }
            update() {
                this.findTarget();
                if (this.fireCooldown > 0) this.fireCooldown--;
                if (this.target && this.fireCooldown <= 0) {
                    this.shoot();
                    this.fireCooldown = this.fireRate;
                }
            }
            shoot() {
                const slowEffect = this.slowAmount ? { amount: this.slowAmount, duration: this.slowDuration } : null;
                this.game.projectiles.push(new Projectile(this.x, this.y, this.target, this.damage, slowEffect, this.game));
            }
            draw(ctx) {
                ctx.fillStyle = this.specs.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#95a5a6';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width / 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Projectile {
            constructor(startX, startY, target, damage, slowEffect, game) {
                this.x = startX; this.y = startY; this.target = target;
                this.damage = damage; this.slowEffect = slowEffect;
                this.game = game;
                this.speed = 10; this.size = 4;
            }
            update() {
                if (!this.target || this.target.health <= 0) { this.x = -1000; return; }
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < this.speed) {
                    this.target.takeDamage(this.damage, this.slowEffect);
                    this.x = -1000;
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.slowEffect ? '#aed6f1' : '#f1c40f';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class GeneticAlgorithmAI {
            constructor() {
                this.populationSize = parseInt(numChildrenSlider.value, 10);
                this.mutationRate = 0.1;
                this.generation = 0;
                this.population = [];
                this.evaluating = false;
                this.createInitialPopulation();
            }

            createInitialPopulation() {
                const placementTiles = this.getValidPlacementTiles();
                for (let i = 0; i < this.populationSize; i++) {
                    const genome = [];
                    const numberOfTowers = 5 + Math.floor(Math.random() * 10);
                    const availableTiles = [...placementTiles];
                    for (let j = 0; j < numberOfTowers; j++) {
                        if (availableTiles.length === 0) break;
                        const tileIndex = Math.floor(Math.random() * availableTiles.length);
                        const tile = availableTiles.splice(tileIndex, 1)[0];
                        const towerType = Math.random() < 0.5 ? 'turret' : 'frost';
                        genome.push({ tileX: tile.c, tileY: tile.r, type: towerType });
                    }
                    this.population.push({ genome, fitness: 0 });
                }
                this.setupPopulationInstances();
            }
            
            setupPopulationInstances() {
                childrenContainer.innerHTML = '';
                this.instances = this.population.map((individual, index) => {
                    const instanceContainer = document.createElement('div');
                    instanceContainer.className = 'child-instance';

                    const canvas = document.createElement('canvas');
                    instanceContainer.appendChild(canvas);

                    const statsContainer = document.createElement('div');
                    statsContainer.className = 'child-stats';
                    statsContainer.innerHTML = `
                        <div class="child-stat-item"><span>‚ù§Ô∏è Health:</span> <span id="health-${index}">100</span></div>
                        <div class="child-stat-item"><span>üí∞ Money:</span> <span id="money-${index}">200</span></div>
                        <div class="child-stat-item"><span>üåä Wave:</span> <span id="wave-${index}">0</span></div>
                        <div class="child-stat-item"><span>‚≠ê Fitness:</span> <span id="fitness-${index}">0</span></div>
                    `;
                    instanceContainer.appendChild(statsContainer);
                    childrenContainer.appendChild(instanceContainer);
                    
                    const uiElements = {
                        health: getEl(`health-${index}`),
                        money: getEl(`money-${index}`),
                        wave: getEl(`wave-${index}`),
                        fitness: getEl(`fitness-${index}`)
                    };

                    return new GameInstance(canvas, uiElements, individual.genome);
                });
            }

            getValidPlacementTiles() {
                const tiles = [];
                for (let r = 0; r < originalMapLayout.length; r++) {
                    for (let c = 0; c < originalMapLayout[0].length; c++) {
                        if (originalMapLayout[r][c] === 0) {
                            tiles.push({ r, c });
                        }
                    }
                }
                return tiles;
            }

            async evaluatePopulation() {
                this.evaluating = true;
                const evaluationPromises = this.instances.map(instance => this.calculateFitness(instance));
                await Promise.all(evaluationPromises);
                
                for(let i = 0; i < this.instances.length; i++) {
                    this.population[i].fitness = this.instances[i].fitness;
                }

                let bestFitness = this.population[0].fitness;
                this.population.sort((a, b) => b.fitness - a.fitness);
                this.selectionAndReproduction();
                this.generation++;
                console.log(`Generation ${this.generation} complete. Best fitness: ${bestFitness}`);
                this.evaluating = false;
            }

            calculateFitness(instance) {
                return new Promise(resolve => {
                    instance.resetState();
                    const simulationInterval = setInterval(() => {
                        if (instance.wave > 10 || instance.gameState === 'gameOver') {
                            clearInterval(simulationInterval);
                            instance.fitness = instance.money - (100 - instance.health) * 5 + instance.wave * 50;
                            if (instance.ui) instance.ui.fitness.textContent = instance.fitness.toFixed(2);
                            resolve();
                            return;
                        }
                        if (!instance.currentWaveActive) {
                            instance.startNextWave();
                        }
                        instance.update();
                    }, 1000 / 60); // Run simulation at 60fps
                });
            }

            selectionAndReproduction() {
                const parents = this.population.slice(0, Math.max(2, Math.floor(this.populationSize * 0.2))); // Top 20% are parents
                const newPopulation = [];
                
                const eliteCount = Math.floor(this.populationSize * 0.1);
                for(let i = 0; i < eliteCount; i++) {
                    newPopulation.push({genome: this.population[i].genome, fitness: 0});
                }

                while (newPopulation.length < this.populationSize) {
                    const parentA = parents[Math.floor(Math.random() * parents.length)].genome;
                    const parentB = parents[Math.floor(Math.random() * parents.length)].genome;
                    const childGenome = this.crossover(parentA, parentB);
                    this.mutate(childGenome);
                    newPopulation.push({ genome: childGenome, fitness: 0 });
                }
                this.population = newPopulation;
                this.setupPopulationInstances();
            }

            crossover(parentA, parentB) {
                const cutPoint = Math.floor(Math.random() * Math.min(parentA.length, parentB.length));
                const childGenome = [...parentA.slice(0, cutPoint), ...parentB.slice(cutPoint)];
                return childGenome;
            }

            mutate(genome) {
                if (Math.random() < this.mutationRate) {
                    if (Math.random() < 0.5 && genome.length > 2) {
                        genome.splice(Math.floor(Math.random() * genome.length), 1);
                    } else {
                        const placementTiles = this.getValidPlacementTiles().filter(t => !genome.some(g => g.tileX === t.c && g.tileY === t.r));
                        if(placementTiles.length > 0) {
                            const tile = placementTiles[Math.floor(Math.random() * placementTiles.length)];
                            genome.push({ tileX: tile.c, tileY: tile.r, type: Math.random() < 0.5 ? 'turret' : 'frost' });
                        }
                    }
                }
                for (let i = 0; i < genome.length; i++) {
                    if (Math.random() < this.mutationRate) {
                        genome[i].type = genome[i].type === 'turret' ? 'frost' : 'turret';
                    }
                }
            }
            
            update() {
                if (this.evaluating) {
                    this.instances.forEach(inst => inst.draw());
                    return;
                };
                this.evaluatePopulation();
            }
        }

        class AIManager {
            constructor() {
                this.active = false;
                this.aiStrategy = null;
            }

            start(mode) {
                this.stop();
                this.active = true;
                document.querySelector('.main-content').style.display = 'none';
                childrenContainer.style.display = 'flex';
                if (mode === 'ga') {
                    this.aiStrategy = new GeneticAlgorithmAI();
                } else {
                    this.active = false;
                    console.error("Unknown AI mode:", mode);
                    return;
                }
            }

            stop() {
                this.active = false;
                this.aiStrategy = null;
                document.querySelector('.main-content').style.display = 'flex';
                childrenContainer.style.display = 'none';
                childrenContainer.innerHTML = '';
            }

            update() {
                if (!this.active || !this.aiStrategy) return;
                this.aiStrategy.update();
            }
        }

        // --- Game Logic ---
        function setupLevel(levelIndex) {
            const level = maps[levelIndex];
            originalMapLayout = JSON.parse(JSON.stringify(level.layout));
            mapLayout = JSON.parse(JSON.stringify(originalMapLayout));
        }

        function init() {
            updateColors();
            setupLevel(0);
            calculatePath();
            buildTowerSelector();
            aiManager = new AIManager();
            mainGame = new GameInstance(mainCanvas);
            mainGame.resizeCanvas();
            gameLoop();
        }

        function calculatePath() {
            path = [];
            let startPos;
            for (let r = 0; r < originalMapLayout.length; r++) { for (let c = 0; c < originalMapLayout[0].length; c++) { if ((originalMapLayout[r][c] === 1 || originalMapLayout[r][c] === 2) && (r === 0 || c === 0 || r === originalMapLayout.length - 1 || c === originalMapLayout[0].length - 1)) { startPos = { r, c }; break; } } if (startPos) break; }
            if (!startPos) { console.error("No starting point found!"); return; }
            let current = startPos;
            let visited = new Set();
            visited.add(`${current.r},${current.c}`);
            while (true) {
                path.push({ x: current.c * TILE_SIZE + TILE_SIZE / 2, y: current.r * TILE_SIZE + TILE_SIZE / 2 });
                if (originalMapLayout[current.r][current.c] === 2) break;
                const neighbors = [{ r: current.r - 1, c: current.c }, { r: current.r + 1, c: current.c }, { r: current.r, c: current.c - 1 }, { r: current.r, c: current.c + 1 }];
                let foundNext = false;
                for (const n of neighbors) {
                    if (n.r >= 0 && n.r < originalMapLayout.length && n.c >= 0 && n.c < originalMapLayout[0].length && (originalMapLayout[n.r][n.c] === 1 || originalMapLayout[n.r][n.c] === 2) && !visited.has(`${n.r},${n.c}`)) {
                        current = n;
                        visited.add(`${current.r},${current.c}`);
                        foundNext = true;
                        break;
                    }
                }
                if (!foundNext) break;
            }
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            if (aiManager.active) {
                aiManager.update();
            } else {
                mainGame.update();
                mainGame.draw();
                drawPlacementPreview();
                updateUI();
            }
        }
        
        function updateUI() {
            healthEl.textContent = mainGame.health;
            moneyEl.textContent = mainGame.money;
            waveEl.textContent = mainGame.wave;
            enemiesLeftEl.textContent = mainGame.enemies.length;
        }

        function drawPlacementPreview() {
            if (mainGame.gameState === 'gameOver' || !selectedTowerType) return;
            const tileX = Math.floor(mouse.x / TILE_SIZE);
            const tileY = Math.floor(mouse.y / TILE_SIZE);
            if (tileX < 0 || tileX >= mapLayout[0].length || tileY < 0 || tileY >= mapLayout.length) return;
            const towerSpec = TOWER_SPECS[selectedTowerType];
            const canPlace = mainGame.mapLayout[tileY][tileX] === 0 && mainGame.money >= towerSpec.cost;
            mainCtx.fillStyle = canPlace ? 'var(--tower-placement-allowed)' : 'var(--tower-placement-denied)';
            mainCtx.fillRect(tileX * TILE_SIZE, tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }

        function buildTowerSelector() {
            towerSelectionUI.innerHTML = '';
            Object.keys(TOWER_SPECS).forEach(type => {
                const spec = TOWER_SPECS[type];
                const el = document.createElement('div');
                el.className = 'tower-option';
                el.dataset.towerType = type;
                el.innerHTML = `<div class="tower-icon">${spec.icon}</div><div>${spec.name}</div><div class="tower-cost">Cost: ${spec.cost}</div>`;
                el.addEventListener('click', () => selectTowerType(type));
                towerSelectionUI.appendChild(el);
            });
            selectTowerType(Object.keys(TOWER_SPECS)[0]);
        }

        function selectTowerType(type) {
            selectedTowerType = type;
            document.querySelectorAll('.tower-option').forEach(el => {
                el.classList.toggle('selected', el.dataset.towerType === type);
            });
        }

        // --- Event Handlers ---
        function handleCanvasClick(event) {
            if (aiManager.active || mainGame.gameState === 'gameOver') return;
            if (mainGame.gameState === 'idle') mainGame.gameState = 'playing';
            
            const rect = mainCanvas.getBoundingClientRect();
            const scaleX = mainCanvas.width / rect.width;
            const scaleY = mainCanvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);

            if (!selectedTowerType) return;
            if (tileX < 0 || tileX >= mapLayout[0].length || tileY < 0 || tileY >= mapLayout.length) return;
            
            if (mainGame.mapLayout[tileY][tileX] === 0) {
                const cost = TOWER_SPECS[selectedTowerType].cost;
                if (mainGame.money >= cost) {
                    mainGame.money -= cost;
                    const towerX = tileX * TILE_SIZE + TILE_SIZE / 2;
                    const towerY = tileY * TILE_SIZE + TILE_SIZE / 2;
                    mainGame.towers.push(new Tower(towerX, towerY, tileX, tileY, selectedTowerType, mainGame));
                    mainGame.mapLayout[tileY][tileX] = 3;
                }
            }
        }

        function handleMouseMove(event) {
            const rect = mainCanvas.getBoundingClientRect();
            const scaleX = mainCanvas.width / rect.width;
            const scaleY = mainCanvas.height / rect.height;
            mouse.x = (event.clientX - rect.left) * scaleX;
            mouse.y = (event.clientY - rect.top) * scaleY;
        }

        numChildrenSlider.addEventListener('input', () => {
            numChildrenLabel.textContent = `Children: ${numChildrenSlider.value}`;
            if (aiManager.active && aiManager.aiStrategy instanceof GeneticAlgorithmAI) {
                aiManager.aiStrategy.populationSize = parseInt(numChildrenSlider.value, 10);
            }
        });

        startWaveBtn.addEventListener('click', () => {
            if (mainGame.gameState === 'idle') mainGame.gameState = 'playing';
            mainGame.startNextWave();
        });
        
        restartGameBtn.addEventListener('click', () => {
            messageModal.style.display = 'none';
            mainGame.resetState();
        });

        startGaBtn.addEventListener('click', () => aiManager.start('ga'));
        stopAiBtn.addEventListener('click', () => aiManager.stop());
        mainCanvas.addEventListener('click', handleCanvasClick);
        mainCanvas.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('resize', () => { mainGame.resizeCanvas(); });

        init();
    </script>
</body>
</html>
